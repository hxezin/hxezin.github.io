1:HL["/_next/static/css/7af17e192afd46d5.css",{"as":"style"}]
0:["-b0OXOXsjYE8tc2_WFEf6",[[["",{"children":["blog",{"children":[["year","2022","d"],{"children":[["slug","react-key","d"],{"children":["__PAGE__?{\"year\":\"2022\",\"slug\":\"react-key\"}",{}]}]}]}]},"$undefined","$undefined",true],"$L2",[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/7af17e192afd46d5.css","precedence":"next"}]],"$L3"]]]]
4:I{"id":40904,"chunks":["685:static/chunks/685-12dc0bcde1bbed42.js","185:static/chunks/app/layout-2ca1182c785513ae.js"],"name":"","async":false}
5:I{"id":47767,"chunks":["272:static/chunks/webpack-a2bf018d676cef48.js","971:static/chunks/fd9d1056-b7a54ebfd8b98df8.js","596:static/chunks/596-70dae8fbe44c6b74.js"],"name":"default","async":false}
6:I{"id":57920,"chunks":["272:static/chunks/webpack-a2bf018d676cef48.js","971:static/chunks/fd9d1056-b7a54ebfd8b98df8.js","596:static/chunks/596-70dae8fbe44c6b74.js"],"name":"default","async":false}
8:I{"id":56769,"chunks":["222:static/chunks/222-f831eea5ca464177.js","279:static/chunks/279-b22c4d90cc224e29.js","424:static/chunks/app/blog/[year]/[slug]/page-03146577eb3c616a.js"],"name":"","async":false}
9:T1092,
리액트에서 동적인 배열을 렌더링해야 할 때, 자바스크립트 배열의 내장함수 `map()`을 사용하여 일반 데이터 배열을 리액트 엘리먼트로 이루어진 배열로 변환해줍니다.

하지만 그냥 map()을 사용하여 배열을 렌더링한 후 콘솔을 열어보면 다음과 같은 에러를 볼 수 있습니다. 리액트에서 배열을 렌더링 할 때에는 `key`라는 props를 설정해야합니다.

![](221117.png)

## Key

`key`는 리액트가 **어떤 항목을 변경, 추가 또는 삭제할지 식별**할 것을 돕습니다. key는 **엘리먼트에 안정적인 고유성을 부여하**기 위해 배열 내부의 엘리먼트에 지정해야 합니다.

예를 들어서 다음과 같이 배열을 렌더링한다고 가정해보겠습니다.

```js
const array = ['a', 'b', 'c', 'd']

array.map(item => <div>{item}</div>)
```

위 배열의 b와 c 사이에 z를 삽입하게 된다면, 리렌더링을 하게 될 때 `<div>b</div>`와 `<div>c</div>` 사이에 새 `div` 태그를 삽입하는 것이 아니라, 기존의 c가 z로 바뀌고, d는 c로 바뀌고 맨 마지막에 d가 새로 삽입됩니다.

그 다음 a를 제거하게 된다면, 기존의 a가 b로 바뀌고, b는 z로 바뀌고, z는 c로 바뀌고, c는 d로 바뀌고, 맨 마지막에 있는 d가 제거됩니다.

![](221117-2.gif)

이처럼 key가 없다면 Virtual DOM을 비교하는 과정에서 리스트를 순차적으로 비교하면서 변화를 감지합니다. 즉, key가 없는 경우 **변경이 필요하지 않은 리스트의 요소까지 변경**이 일어나게 되므로 비효율적이라고 할 수 있습니다.

이런 부분을 개선하기 위해서 key를 사용할 수 있습니다. 이번엔 객체에 key로 사용할 수 있는 고유한 값(id)을 지닌 배열이 있고, 배열의 id를 key로 사용하여 렌더링 한다고 가정하겠습니다.

```js
const array = [
  {
    id: 0,
    text: 'a',
  },
  {
    id: 1,
    text: 'b',
  },
  {
    id: 2,
    text: 'c',
  },
  {
    id: 3,
    text: 'd',
  },
]

array.map(item => <div key={item.id}>{item.text}</div>)
```

![](221117-3.gif)

이처럼 리스트를 렌더링할 때 고유한 key 값이 있다면 리스트가 업데이트 될 때마다 변경되지 않은 값들은 그대로 두고, 원하는 값을 삽입하거나 삭제할 수 있습니다.

## key의 올바른 사용법

key를 선택하는 가장 좋은 방법은 리스트의 다른 항목들 사이에서 해당 항목을 **고유하게 식별할 수 있는 문자열**을 사용하는 것입니다. 고유한 값은 배열이 다시 렌더링 되는 과정에서 리스트 항목의 순서를 보장할 수 있기 때문입니다. 대부분의 경우 데이터의 `ID`를 key로 사용합니다. 만약 중복되는 key가 있을 때에는 렌더링시에 오류메시지가 콘솔에 나타나게 되며, 업데이트가 제대로 이루어지지 않게 됩니다

## key로서의 index

렌더링 한 항목에 대한 안정적인 ID가 없다면 최후의 수단으로 항목의 `index`를 key로 사용할 수 있습니다. 하지만 **항목의 순서가 바뀔 수 있는 경우** key에 index를 사용하는 것은 권장하지 않습니다.

key는 리액트가 DOM 요소를 식별하는 데 사용하는 유일한 값입니다. 항목을 추가 또는 삭제할 경우, 각 항목의 index 또한 재배치됩니다. 그 결과 key를 변경시켜 렌더링 성능을 저하시킬 우려가 있습니다.

하지만 다음과 같은 경우, key로 index를 사용할 수 있습니다.

- 리스트와 항목이 고정되어, 다시 계산되거나 수정되지 않는다.
- 리스트의 아이템에 id가 없다.
- 리스트가 재배치되거나 필터되지 않는다.

## 참고자료

[React 공식 문서 | 리스트와 Key](https://ko.reactjs.org/docs/lists-and-keys.html)

[벨로퍼트와 함께하는 모던 리액트 | 배열 렌더링하기](https://react.vlpt.us/basic/11-render-array.html)

[Index as a key is an anti-pattern](https://robinpokorny.medium.com/index-as-a-key-is-an-anti-pattern-e0349aece318)

[리액트의 Key를 알아보자](https://tecoble.techcourse.co.kr/post/2021-04-25-react-key/)
2:[null,["$","html",null,{"lang":"en","children":["$","body",null,{"suppressHydrationWarning":true,"children":[["$","$L4",null,{}],["$","main",null,{"className":"max-w-3xl mx-auto px-4 py-16","children":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":"404"}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]],"notFoundStyles":[],"childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children",["year","2022","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$","$L5",null,{"parallelRouterKey":"children","segmentPath":["children","blog","children",["year","2022","d"],"children",["slug","react-key","d"],"children"],"error":"$undefined","errorStyles":"$undefined","loading":"$undefined","loadingStyles":"$undefined","hasLoading":false,"template":["$","$L6",null,{}],"templateStyles":"$undefined","notFound":"$undefined","notFoundStyles":"$undefined","childProp":{"current":["$L7",["$","section",null,{"children":["$","$L8",null,{"post":{"slug":"2022/react-key","title":"리액트에서 key의 역할","description":"리액트 컴포넌트에서 배열을 렌더링할 때 사용되는 key의 역할과 중요성에 대해 알아봅니다.","date":"2022-11-17","keyword":["React"],"content":"$9"}}]}],null],"segment":"__PAGE__?{\"year\":\"2022\",\"slug\":\"react-key\"}"},"styles":[]}],"segment":["slug","react-key","d"]},"styles":[]}],"segment":["year","2022","d"]},"styles":[]}],"segment":"blog"},"styles":[]}]}]]}]}],null]
3:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"리액트에서 key의 역할"}],["$","meta","2",{"name":"viewport","content":"width=device-width, initial-scale=1"}],["$","meta","3",{"property":"og:title","content":"리액트에서 key의 역할"}],["$","meta","4",{"property":"og:description","content":"리액트 컴포넌트에서 배열을 렌더링할 때 사용되는 key의 역할과 중요성에 대해 알아봅니다."}],["$","meta","5",{"name":"twitter:card","content":"summary"}],["$","meta","6",{"name":"twitter:title","content":"리액트에서 key의 역할"}],["$","meta","7",{"name":"twitter:description","content":"리액트 컴포넌트에서 배열을 렌더링할 때 사용되는 key의 역할과 중요성에 대해 알아봅니다."}],["$","link","8",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
7:null
